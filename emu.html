<html>
    <head>
        <script src="codemirror/lib/codemirror.js"></script>
        <link href="https://fonts.googleapis.com/css?family=VT323&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="codemirror/lib/codemirror.css">
        <link rel="stylesheet" href="codemirror/theme/darcula.css">
        <link rel="stylesheet" href="css/ultra.css">
        <!--<script src="codemirror/mode/simple/simple.js"></script>
        
        <script src="codemirror/mode/z80/z80.js"></script>!-->
        <script src="./js/file.mjs" type="module"></script>
        
        <script src="./codemirror/mode/ultra/ultra.js"></script>
        <script src="./codemirror/mode/javascript/javascript.js"></script>
        <script src="./js/cpu/common.mjs" type="module"></script>
        <!--<script src="./js/bus/io.mjs" type="module"></script>!-->
        
        <script src="./js/cpu/index.mjs" type="module"></script>
        <script src="./js/cpu/symbol.mjs" type="module"></script>
        <script src="./js/test.mjs" type="module"></script>
        <script src="./js/device/vt52.mjs" type="module"></script>
        <script src="./js/device/rt11.mjs" type="module"></script>
        <script src="./js/device/keyboard.mjs" type="module"></script>
        <!--<script src="./js/device/commport.mjs" type="module"></script>!-->
        <script src="./js/io/io2.mjs" type="module"></script>
        <script src="./js/ui/buttons.mjs" type="module"></script>
    <style>
        
    </style>
    <script type="module">
        import {FileManager,fm,fs} from './js/file.mjs';
        import {IO_DTE,IO_DCE, IO_WRITE, IO_READ, IO_NONE, IOStream, IOBus, DevNullBus, devnull} from './js/bus/io.mjs';
        import {CPU,cpu,Symbols,LineAware,Memory,Operation,Flag,Register} from './js/cpu/index.mjs';
        import {Hexer8,Hexer16} from './js/cpu/common.mjs';
        import {ControlButton,ValueDisplay} from './js/ui/buttons.mjs';
        import {SyntaxError,parse} from './js/test.mjs';
        window.fs = fs;
        import {RS232Connection,io_ex} from './js/io/io2.mjs';
        import {TTYKeyboard} from './js/device/keyboard.mjs';
        import {VT52,VT52Error} from './js/device/vt52.mjs';
        import {RT11} from './js/device/rt11.mjs';
        import {CommPort} from "./js/device/commport.mjs";

        let editor = null;
        let parseOn = true;
        let currentFile = null;
        window.loadTextData = function(type, filenames,cb) {
                if (typeof(filenames) === 'string') {
                    filenames = [filenames];
                }
                filenames.forEach(f => {
                    const path = "./data/" + type + "/" + f;
                    const req = new XMLHttpRequest();
                    req.open("GET", path, true);
                    req.onreadystatechange = () => {
                        if (req.readyState == XMLHttpRequest.DONE){
                            cb(req.responseText);
                        }
                    }; 
                    req.send();
                });
            }
        window.loadFile = (id) => {
            let pv = parseOn;
            parseOn = false;
            window.editor.setValue(localStorage.getItem(id));
            currentFile = id;
            parseOn = pv;
            if (parseOn) {
                window.reset();
            }
        };
        window.deleteFile = (id) => {
            fm.remove(id);
            document.getElementById(id).parentNode.removeChild(document.getElementById(id));
            currentFile = null;
            window.editor.setValue(document.getElementById("code").value);
        }
        window.persist = (nf) => {
            if (currentFile && !nf) {
                fm.update(currentFile,window.editor.getValue());
            } else {
                let name = document.getElementById("current-save").value;
                if (name && name.trim().length > 4) {
                    currentFile = fm.addFile(name,window.editor.getValue());
                    window.refreshFiles();
                } else {
                    alert("No filename supplied");
                }
            }
        }
        window.showRAM = () => {
            document.getElementById("file-wrap").setAttribute("hidden","");
            document.getElementById("ram-wrap").removeAttribute("hidden");
            document.getElementById("stack-wrap").setAttribute("hidden","");
        }
        window.showFiles = () => {
            document.getElementById("stack-wrap").setAttribute("hidden","");
            document.getElementById("file-wrap").removeAttribute("hidden");
            document.getElementById("ram-wrap").setAttribute("hidden","");
        }
        window.showStack = () => {
            document.getElementById("file-wrap").setAttribute("hidden","");
            document.getElementById("stack-wrap").removeAttribute("hidden");
            document.getElementById("ram-wrap").setAttribute("hidden","");
        }


        window.new_file = () => {
            window.editor.setValue(code.value);
        }
        window.lineNumberFormatter = (line) => {
            if (!window.editor) {
                return Hexer8(line);
            } else if (LineAware.lines.length === 0) {
                try {
                    window.reset();
                } catch (err) {
                    //console.log(err);
                }
            }
            let l = LineAware.memoryAddress(line);
            if (l >= 0) {
                try {
                    return Hexer16(l) + " " + Hexer16(Memory.read(l));
                } catch (e) {
                    return "ER R OR: " + l;
                }
            }
            return "";
        }

        window.reset = () => {
            cpu.halt();
            CPU.reset();
            window.resetMem();
            let c = window.editor.getValue().trim();
            try {
                parse(c);
                window.editor.setValue(c);
            } catch (err) {
                console.log(err);
            }
            
        }
        window.el = (id) =>{
            return document.getElementById(id);
        }

        window.execSlow = () => {
            window.exec(parseInt(window.el('cycle-counter').value));
        }
        window.exec = (cycles) => {
            window.initExecution();

            if (cycles) {
                cpu.execSlow(cycles);
            } else {
                cpu.exec();
            }
        }
        window.initExecution = () => {
            window.resetMem();

            cpu.process();
            //parse(window.editor.getValue().trim());
            window.has_stack = Symbols.resolve("stack_top") !== null;
            let stack = document.getElementById("stack");
            while(stack.hasChildNodes()) {
                stack.removeChild(stack.lastChild);
            }
            if (window.has_stack ) {
                window.stack_top =Symbols.resolve("stack_top").value;
                window.stack_size = Symbols.resolve("stack_size").value;
                window.stackOut = [];
                for (let i = 0; i < window.stack_size;i++) {
                    let tda = document.createElement("td");
                    let tdv = document.createElement("td");
                    tda.innerText = Hexer16(window.stack_top-i);
                    tdv.innerText = Hexer16(0);
                    window.stackOut.push(tdv);
                    let r = document.createElement("tr");
                    r.appendChild(tda);
                    r.appendChild(tdv);
                    stack.appendChild(r);
                }
            }
        }
        window.controlButtons = [];
        window.createButtons =() => {
            
            window.controlButtons.push(new ControlButton("Run",window.exec,true));
            window.controlButtons.push(new ControlButton("Run Slow",window.execSlow,true));
            window.controlButtons.push(new ControlButton("Reset",window.reset,true));
            window.controlButtons.push(new ControlButton("Step",window.step,true));
            window.controlButtons.push(new ControlButton("Toggle Parse",() => window.toggleParse(),true,true));
            //window.controlButtons.push(new ControlButton("Save",() => window.persist(),true,false));
            //window.controlButtons.push(new ControlButton("New File",() => window.mew_file(),true,false));
            //window.controlButtons.push(new ControlButton("Toggle screen",() => window.screen_tooggle(),true,true));
            
            let d = document.getElementById("cm-buttons");
            console.log(d);
            for(let i = 0; i < window.controlButtons.length;i++) {
                d.appendChild(window.controlButtons[i].element);
            }
            
        }
        window.step = () => {
            if (cpu.cycles === 0) {
                window.initExecution();
            }
            cpu.step();
            let memPos = 0;
            let next = cpu.instruction;
            let g = window.editor.getGutterElement();
            
            for (let i = 0; i < window.editor.lineCount();i++) {
                window.editor.removeLineClass(i,"wrap","ultralight");
                window.editor.removeLineClass(i,"gutter","ultralight");
                
                memPos = LineAware.memoryAddress(i);    
                if (memPos === next) {
                    window.editor.addLineClass(i,"wrap","ultralight");
                    window.editor.addLineClass(i,"gutter","ultralight");
                }
                
            }

            /*let lines = Array.from(document.querySelectorAll(".CodeMirror-linenumber")).filter(ll => ll.innerText.length>8);
            lines.forEach(ll => {
                let addr = parseInt(ll.innerText.substring(2,4),16);
                ll.innerText = Hexer16(addr) + " " + Hexer16(Memory.read(addr));
            });*/
            
            document.getElementById("register-r").innerText = "R: " + Hexer16(Register.R.value);
            
        }
        window.init = () => {
            let code = document.getElementById("code");
            let ram = document.getElementById("ram");
            let files = document.getElementById("file");
            let ramOut = [];

            for (let i = 0; i < 1024;i++) {
                let r = document.createElement("tr");
                let tda = document.createElement("td");
                let tdb = document.createElement("td");
                tda.innerText = Hexer16(i);
                tdb.innerText = Hexer16(0);
                r.appendChild(tda);
                r.appendChild(tdb);
                ram.appendChild(r);
                ramOut.push(r);
                ramOut.push(tdb);
            }
            window.saveFile = () => {
                let r = document.createElement("tr");
                let tda = document.createElement("td");
                let tdb = document.createElement("td");
                let tdc = document.createElement("td");
                let name = document.createElement("input");
                name.type="text";
                name.id="current-save";
                name.placeholder="<filename>";
                name.classList.add("ultra-btn");
                tda.appendChild(name);
                tdb.innerText = "...";
                tdc.innerHTML = "<a class='ultra-btn' href='javascript:persist(true)'>Save</a><br>";
                r.appendChild(tda);
                r.appendChild(tdb);
                r.appendChild(tdc);
                r.id="save-row"
                files.insertBefore(r,files.firstChild);
            }
            window.refreshFiles = () => {
                let fileList = fm.list;
                files.innerHTML = "";
                for (let i = 0; i < fileList.length;i++) {
                    let r = document.createElement("tr");
                    let tda = document.createElement("td");
                    let tdb = document.createElement("td");
                    let tdc = document.createElement("td");
                    tda.innerText = fileList[i].name;
                    tdb.innerText = fileList[i].updated;
                    tdc.innerHTML = "<a class='ultra-btn' href='javascript:loadFile(\"" + fileList[i].id + "\")'>Load</a><br>" +
                                    "<a class='ultra-btn' href='javascript:deleteFile(\"" + fileList[i].id + "\")'>Delete</a>";
                    r.id = fileList[i].id;
                    r.appendChild(tda);
                    r.appendChild(tdb);
                    r.appendChild(tdc);
                    files.appendChild(r);
                }
            };
            window.refreshFiles();
            window.resetMem = () => {
                for(let i = 0; i < ramOut.length;i+=2) {
                    //ramOut[i].style.visibility = 'collapse';
                    ramOut[i+1].innerText = Hexer16(Memory.read(i/2));
                }
            }
            window.readMem = () => {
                for (let i = 0; i < ramOut.length;i+=2) {
                    ramOut[i+1].innerText = Hexer16(Memory.read(i/2));
                }
            }
            window.toggleParse = () => {parseOn=!parseOn;}
            Memory._mem.onchange = (type,latest)=> {
                if (latest.addr < ramOut.length && document.getElementById("ram-wrap").getAttribute("hidden")) {
                    let i = latest.addr*2;
                    ramOut[i+1].innerText = Hexer16(latest.datum);
                    ramOut[i].style.visibility='visible'
                } else if (window.has_stack && latest.addr>=window.stack_top-window.stack_size && latest.addr<=window.stack_top) {
                    window.stackOut[window.stack_top-latest.addr].innerText = Hexer16(latest.datum);
                }
            };
            let keyboardConnection = new RS232Connection(2);
            let vt = new VT52(9600,2);

            //vt.modem = connection.modem;

            //Register.IN.connect(keyboardConnection);
            let keyboard = new TTYKeyboard();
            io_ex.register(keyboard);
            keyboard.connect(keyboardConnection);
            let keyboard_input = document.getElementById("keyboard-input");
            let cmd = false;
            keyboard_input.onkeyup = (ev) => {
                if (!cpu.running) {
                    return;
                }
                if (ev.key === "ESC") {
                    cmd = true;
                    keyboard_input.value = "ESC-";
                } else {
                    if (ev.key.length === 1) {
                        let b = ev.key.charCodeAt(0);
                        if (b <128) {
                            if (cmd) {
                                keyboard_input.value ="ESC-" + ev.key;
                                keyboard.capture.write(0x1b);
                            } else {
                                keyboard_input.value = ev.key;
                            }
                            keyboard.capture.write(b);
                            cmd = false;
                        }
                    } else {
                        if (cmd) {
                            cmd = false;
                        } else if (ev.key.codePointAt(0) < 128 ) {
                            keyboard_input.value = ev.key;
                            keyboard.capture.write(ev.key.codePointAt(0)&0x7f);
                        }
                        
                    }
                }
            };
            vt.update_at_interval(20);
            vt.on('ERROR',(e) => {
                if (e instanceof VT52Error) {
                    console.error(e);
                } else {
                    console.error(e);
                    cpu.halt();
                    vt.active = false;
                }
            });
            let vtb = vt.bus;

            window.screen_toggle = () => {
                if (vt.active) {
                    vt.end();
                    Register.OUT.connect(devnull);
                    document.getElementById("screen-toggle").innerHTML="<strong>Screen ON</strong>";
                } else {
                    Register.OUT.connect(vtb);
                    vt.update_at_interval(20);
                    document.getElementById("screen-toggle").innerHTML="<strong>Screen OFF</strong>";
                }
                
            }

            /**
             * Let us assume we have an io_bus, this has an abitrary number of connections
             *
             */



            let cpuConnect = new RS232Connection(0);
            Register.OUT.connect(cpuConnect);
            vt.connect(cpuConnect);
            //let diskConnect = new RS232Connection(1);
            //Register.IN.connect(diskConnect);
            //Symbols.resolve("file").listener.connect(diskConnect);
            //vtb.port.connect(outBus.port);
            //cp.bus = outBus;
            let fs = new RT11(9600,10);

            let vt_out = document.getElementById("terminal");
            let block = '\u2588';
            let blink = 0;
            /*setTimeout(() => {
                window.loadTextData("txt", "ui.txt", (txt) => {
                    txt = txt.split("\n").map(l => l.split(""));
                    let code = window.editor.getValue().trim().split("\n").map(l => l.split(""));
                    for (let i = 0; i < code.length && i < 22;i++) {
                        let ln = window.lineNumberFormatter(i);
                        txt[i+1].splice(1,ln.length,...ln.split(""));
                        for (let j = 0; j< code[i].length;j++) {
                            try {
                                txt[i+2][j+12] = code[i][j];
                            } catch (e) {
                                console.log(i + "::" + j);
                            }
                        }
                    }
                    txt.forEach(l => vt.rcv_bits(vt.chars_to_bits(l.join("") + "\n")));
                    let th = setInterval(window.update_screen,100);
                })},1000);*/
            window.update_screen = () => {
            
                vt_out.value = vt.visible_rows;
                if (blink >=0) {
                    let pos = vt.cursor_pos;
                    vt_out.value = vt_out.value.substring(0,pos) + block + vt_out.value.substring(pos+1,20000);
                }
                blink++;
                if (blink == 20) {
                    blink = -20;
                }
                window.requestAnimationFrame(window.update_screen);
            };
            window.requestAnimationFrame(window.update_screen)
            //let s_u = setInterval(window.update_screen,100);
            
            window.editor = CodeMirror.fromTextArea(document.getElementById("code"),{
                theme:"darcula",
                //mode:"ultra",
                lineNumbers:true,
                firstLineNumber:0,
                lineNumberFormatter:window.lineNumberFormatter,
                gutters: ["CodeMirror-linenumbers","breakpoints","spacer"]
            });
            let panel = document.getElementById("cm-registers");
            panel.appendChild(document.createElement("br"));
            let cc = createView("reporter-cpu",panel);
            let r = createView("register-r",panel);
            let i = createView("register-i",panel);
            let a = createView("register-a",panel);
            let io_in = createView("register-ioin",panel);
            let io_out = createView("register-ioout",panel);
            cpu.onchange = (type,value)=> {
                value = ""+value;
                cc.innerText = value;
                /*if (cpu.running) {
                    let len = 0x4B-value.length;
                    vt.rcv_bits(vt.bytes_to_bits([0x1b,0x59,0x3,len]));
                    vt.rcv_bits(vt.chars_to_bits(""+value));
                }*/
            };
            //io_in.style.content = "I/O IN: "
            //io_out.style.content = "I/O OUT: "
            let fc = createView("flag-c",panel);
            let regListener = (type,v) => {
                v = Hexer16(v);
                switch(type) {
                    case Register.R_T:
                        r.innerText = v;
                        // 
                        /*if (cpu.running) {
                            vt.rcv_bits(vt.bytes_to_bits([0x1b,0x59,0x6,0x47]));
                            vt.rcv_bits(vt.chars_to_bits(v));
                        }*/
                        break;
                    case Register.I_T:
                        i.innerText = v;
                        /*if (cpu.running) {
                            vt.rcv_bits(vt.bytes_to_bits([0x1b,0x59,0x8,0x47]));
                            vt.rcv_bits(vt.chars_to_bits(v));
                        }*/
                        break;
                    case Register.A_T:
                        a.innerText = v;
                        /*if (cpu.running) {
                            vt.rcv_bits(vt.bytes_to_bits([0x1b,0x59,0xA,0x47]));
                            vt.rcv_bits(vt.chars_to_bits(v));
                        }*/
                        break;
                    case Register.IN_T:
                        io_in.innerText = v;
                        /*if (cpu.running) {
                            vt.rcv_bits(vt.bytes_to_bits([0x1b,0x59,0xF,0x47]));
                            vt.rcv_bits(vt.chars_to_bits(v));
                        }*/
                        break;
                    case Register.OUT_T:
                        let existing = io_out.innerHTML.split("<br>").map(u => u.trim()).filter(u => u.length > 0);
                        if (existing.length == 0 || existing[0]!== v) {
                            existing.unshift(v);
                        }
                        io_out.innerHTML = existing.slice(0,5).join("<br>");
                        /*if (cpu.running) {
                            vt.rcv_bits(vt.bytes_to_bits([0x1b,0x59,0x11,0x47]));
                            vt.rcv_bits(vt.chars_to_bits(v));
                        }*/
                        break;
                }
            }
            Register.R.onchange = regListener;
            Register.I.onchange = regListener;
            Register.A.onchange = regListener;
            Register.IN.onchange = regListener;
            Register.OUT.onchange = regListener;
            Flag.C.onchange = (flagType, value) => {
                fc.innerText = "C: " + value + " [" + Flag.C.f + "]";
                /*if (cpu.running) {
                    value = value==1 || value;
                    vt.rcv_bits(vt.bytes_to_bits([0x1b,0x59,0xC,0x47]));
                    vt.rcv_bits(vt.chars_to_bits(value?"TRUE":"FALSE"));
                }*/
            }
            window.editor.on("gutterClick", function(cm, n) {
                console.log(n);
                var info = cm.lineInfo(n);
                cm.setGutterMarker(n, "breakpoints", info.gutterMarkers ? null : makeMarker());
            });
            let last = null;
            window.editor.on('change', () => {
                
            });
            window.editor.on("changes", () => {
                localStorage.setItem("_asm",document.getElementById("code").value);
                if (parseOn) {

                    CPU.reset();

                    try {
                        parse(window.editor.getValue().trim());
                    } catch (err) {
                        console.log(err);
                    }
                }
            });
            window.editor.setSize(640,720);
            window.createButtons();
            
        }
        function createView(id,panel) {
            let r = document.createElement("span");
            r.id = id;
            r.className = "CodeMirror-reporter";
            let regname =  id.split("-")[1].toUpperCase() + ": ";
            if (regname.indexOf("IO") == 0) {
                regname = "I/O " + regname.substring(2);
            } else if (regname.indexOf("CPU") == 0) {
                regname = "Cycle: ";
            }
            r.setAttribute("regname",regname);
            panel.appendChild(r);
            return r;
        }
        function makeMarker() {
            var marker = document.createElement("div");
            marker.style.color = "#822";
            marker.innerHTML = "●";
            return marker;
        }
        
    </script>
    </head>
    <body onload="init()">

        
        <span style='display:none;font-size: 32px;width:100%;background-color: darkred;color:whitesmoke;font-weight: bolder;font-family:Arial, Helvetica, sans-serif; padding:10px;'>If this just looks insane, start <a href='./intro.html'>Here</a>. Also have a look at <a href='./emu_issues.html'>Known Issues</a></span>
        <!--<div id='cm-buttons' class="CodeMirror-buttonsPanel">
            <input type="number" value="10" id="cycle-counter"/>
            <input type="text" autocomplete="off" value="" id="keyboard-input"/>
        </div>!-->
        <table style="width:80%">

        <tr>
            <td style="vertical-align: top;">
                <div id='cm-registers' class="CodeMirror-regpanel"></div>
            </td>
            <td>
                <div id='cm-buttons' class="CodeMirror-buttonsPanel">
                    <input type="number" value="4000"  class='CodeMirror-reporter' id="cycle-counter"/>
                </div>
                <input type="text" autocomplete="off"  disabled style="width:95%;margin-left:10px;margin-top:5px;" placeholder="keyboard off" class='CodeMirror-reporter'value="" id="keyboard-input"/>


        <textarea id="code">
; Unmutable
    .const
        .zero 0
        .one 1
        .two 2
        .three 3
        .four 4
        .five 5
        .six 6
        .seven 7
        .sixteen 16
        .not_sixteen 0xFFEF
        .max 0xFFFF
        .neg_one 0xFFFE
        .opmask 0xC000
        .addmask 0x3FFF
        .op_nand 0
        .op_add 0x4000
        .op_sav 0x8000
        .op_jcz 0xC000
        .stack_push 0x4000
        .stack_pop 0x3fff
        .thousand 0x4000
        .stack_top 0x740
        .stack_size 0x200
        .reserve_io_buffers 4
        .reserve_mutable 0x400
    ; Mutable variables
    ; Note that this particular program does
    ; something very useful...
    ; change the value of .tmp2 and see
    ; what happens on the stack. Don't know where you can see the stack?
    ; On the right side of the screen, above the file listing there's a
    ; button labeled stack. That's it. Since RUN doesn't report the state
    ; back it's probably more useful to use Run slow or to step but I haven't
    ; bothered figuring out how to get CodeMirror to scroll to the current
    ; line yet so that will require you to do some scrolling. Or a lot of it.
    .data
    	.truejmp 0
        .falsejmp 0
    	.tmp1 0x629
        .tmp2 0x27
        .stack_scratch 0
        .stack_tmp1 0
        .stack_tmp2 0
    	.stackp 0x741
    ioex:
    	jcz main
    call_ioex:
    	jcz ioex
    ; MAIN
    main:
        add call_mn1
        sav call_return
    	jcz push


    call_mn1:
    	jcz mn1
    call_mn2:
    	jcz mn2
    call_mn3:
    	jcz mn3
    call_mn4:
    	jcz mn4
    mn1:
    	nand zero
        nand max
        add tmp2
        sav tmp1
        nand zero
        nand max
        add call_mn2
        sav call_return
        jcz push
    mn2:
    	nand zero
        nand max
        add call_end
        sav call_return
        jcz uvmsub
    mn3:
    	nand zero
        nand max
        add tmp2
        sav tmp1
        nand zero
        nand max
        add call_mn4
        sav call_return
        jcz push
    mn4:
    	nand zero
        nand max
        add call_end
        sav call_return
        jcz uvmsub
    call_end:
    	jcz end
    end:
    sav zero

    call_poll:
    	jcz poll
    call_poll_check:
    	jcz poll_check
    call_poll_push:
    	jcz poll_push
    poll:
    	add op_jcz
        sav truejmp

    	nand zero
        nand max
        add call_return
        sav stack_scratch
        nand zero
        nand max
        add call_poll_check
        sav ioex
        jcz ioex
    poll_check:
    	sav tmp2
        add max
        jcz uvm_falsejump
        nand zero
        nand max
        add tmp2
        sav tmp1
        nand zero
        nand max
        add truejmp
        sav call_return
        jcz poll

    uvmalloc:
    	sav tmp1
        nand tmp1
        add stackp
        sav tmp1
        nand zero
        nand max
        add stackp
        sav tmp2
        nand zero
        nand max
        add tmp1
        sav stackp
        nand zero
        nand max
        add tmp2
        sav tmp1
        jcz call_return
    uvmfree:
    	add stackp
        sav stackp
        jcz call_return
    uvmload:
    	nand zero
        nand max
        add call_uvmload_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmload_1:
    	jcz uvmload_1
    uvmload_1:
    	add stack_tmp1
        sav stack_tmp2
        nand zero
        nand max
        add stack_tmp1
        nand max
        sav stack_tmp1
    	nand zero
        nand max
        add call_uvmload_loop
        sav call_return
    uvmload_loop:
    	nand zero
        nand max
        add stack_tmp1
        add one
        jcz uvmload_cont
        	nand zero
            nand max
            add stack_scratch
            sav call_return
            jcz call_return
    uvmload_cont:
    	nand zero
        nand max
        add stack_tmp2
        add max
        sav stack_tmp2
        add op_add
        sav uvmload_fetch
        nand zero
        nand max
    uvmload_fetch:
    	add zero
        sav tmp1
        jcz push
    call_uvmload_loop:
    	jcz uvmload_loop

    ; sav stack(0) words starting at
    ; memory address stack(1)
    uvmsav:
    	nand zero
        nand max
        add call_uvmsav_1
        sav alu_return
        jcz alu_pop
    call_uvmsav_1:
    	jcz uvmsav_1
    uvmsav_1:
    	add op_add
        sav stack_tmp2
        sav uvmsav_load_2
        nand zero
        nand max
        add stack_tmp1
        nand max
        sav stack_tmp1
        nand zero
        nand max
        add call_uvmsav_loop
       	sav call_return
     uvmsav_loop:
     	nand zero
        nand max
        add stack_tmp1
        add one
        jcz uvmsav_load
        	nand zero
            nand max
            add stack_scratch
            sav call_return
            jcz call_return
     uvmsav_load:
     	nand zero
        nand max
    uvmsav_load_2:
     	add zero
        sav tmp1
        jcz push
    call_uvmsav_loop:
    	jcz uvmsav_loop
    uvmhalt:
    	sav zero

    uvmjmp:
    	add op_jcz
        sav call_return
        jcz call_return

    uvmjnz:
    	add op_jcz
        sav truejmp
    	nand zero
        nand max
        add call_return
        sav falsejmp
        nand zero
        nand max
        add call_uvmjnz_1
        sav call_return
        jcz pop
    call_uvmjnz_1:
    	jcz uvmjnz_1
    uvmjnz_1:
    	nand zero
        nand max
        add tmp1
        add max
        jcz uvm_falsejmp
        jcz uvm_truejmp

    uvmjez: ;
    	add op_jcz
        sav truejmp
    	nand zero
        nand max
        add call_return
        sav falsejmp
        nand zero
        nand max
        add call_uvmjez_1
        sav call_return
        jcz pop
    call_uvmjez_1:
    	jcz uvmjez_1
    uvmjez_1:
    	nand zero
        nand max
        add tmp1
        add max
        jcz uvm_truejmp
        jcz uvm_falsejmp
    uvm_falsejmp:
        nand zero
        nand max
        add falsejmp
        sav call_return
        jcz call_return

    uvm_truejmp:
    	nand zero
        nand max
        add op_jcz
        add truejmp
        sav uvm_trjmp_do
        add zero
    uvm_truejmp_do:
    	jcz zero


    alu_peek:
    	nand zero
        nand max
        add call_return
        sav stack_scratch
        nand zero
        nand max
        add op_add
        add stackp
        sav alu_peek_1
        add one
        sav alu_peek_2
        nand zero
        nand max
    alu_peek_1:
    	add zero
        sav stack_tmp1
        nand zero
        nand max
    alu_peek_2:
    	add zero
        sav stack_tmp2
        sav tmp1
    alu_peek_return:
    	jcz zero

    call_alu_pop_1:
    	jcz alu_pop_1
    call_alu_pop_2:
    	jcz alu_pop_2
    alu_pop:
    	nand zero
        nand max
        add call_return
        sav stack_scratch
        nand zero
        nand max
        add call_alu_pop_1
        sav call_return
        jcz pop
    alu_pop_1:
    	sav stack_tmp1
        nand zero
        nand max
        add call_alu_pop_2
        sav call_return
        jcz pop
    alu_pop_2:
    	sav stack_tmp2
        sav tmp1
    alu_pop_return:
    	jcz zero
    alu_return:
    	nand zero
        nand max
        add stack_scratch
        sav call_return
        jcz push
    ; if NOT(a)+b overflows
    ; then a < b
    ; if NOT(a) + b + 1 inte ger overflow
    ; a > b
    uvmlt:
    	nand zero
        nand max
        add call_uvmlt_1
        sav alu_peek_return
        jcz alu_peek
    call_uvmlt_1:
    	jcz uvmlt_1
    uvmlt_1:
    	nand tmp1
        add stack_tmp1
        jcz uvmlt_2
        jcz uvmtest_false
    uvmlt_2:
    	add one
        jcz uvmtest_true
        jcz uvmtest_false

    uvmgt:
    	nand zero
        nand max
        add call_uvmgt_1
        sav alu_peek_return
        jcz alu_peek
    call_uvmgt_1:
    	jcz uvmgt_1
    uvmgt_1:
    	nand tmp1
        add stack_tmp1
        jcz uvmtest_false
        jcz uvmtest_true

    uvmeq: ;equals
    	nand zero
        nand max
        add call_uvmeq_1
        sav alu_peek_return
        jcz alu_peek
    call_uvmeq_1:
    	jcz uvmeq_1
    uvmeq_1:
    	nand tmp1x
        add stack_tmp1

        add one
        jcz uvmtest_false
        jcz uvmtest_true

    uvmtest_true:
    	nand zero
        nand max
        add one
        sav tmp1
        jcz alu_return

    uvmtest_false:
    	nand zero
        nand max
        sav tmp1
        jcz alu_return

    uvmrsb: ; right shift
    	nand zero
        nand max
        add not_sixteen
        sav tmp2
        nand zero
        nand max
        add op_add
        sav uvmsb_return
        jcz uvmsb

    uvmlsb: ; left shift
    	nand zero
        nand max
        add neg_one
        sav tmp2
        nand zero
        nand max
        add op_jcz
        add call_push
        sav uvmsb_return
        jcz uvmsb

    uvmsb: ; shift
    	nand zero
        nand max
        add call_uvmsb_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmsb_1:
    	jcz uvmsb_1
    uvmsb_1:
    	nand zero
        nand max
        sav stack_tmp2
        add stack_tmp1
        add tmp2
        sav stack_tmp1
    uvmsb_loop:
        nand zero
        nand max
        add stack_tmp1
        add one
        jcz uvmsb_cont
    		uvmsb_return:
            	jcz alu_return
                nand zero
                nand max
                add stack_tmp2
                sav tmp1
                jcz alu_return
    uvmsb_cont:
    	sav stack_tmp1
        nand zero
        nand max
        add stack_tmp2
        add stack_tmp2
        sav stack_tmp2
        nand zero
        nand max
        add tmp1
        add tmp1
        sav tmp1
        jcz uvmsb_loop
        nand zero
        nand max
        add stack_tmp2
        add one
        sav stack_tmp2
        nand zero
    jcz uvmsb_loop


    uvmxor:
    	nand zero
        nand max
        add call_uvmxor_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmxor_1:
    	jcz uvmxor_1
    uvmxor_1:
    	nand stack_tmp1
        sav tmp1
        nand stack_tmp2
        sav stack_tmp2
        nand zero
        nand max
        add tmp1
        nand stack_tmp1
        nand stack_tmp2
        sav tmp1
        nand zero
        nand max
        add stack_scratch
        sav call_return
        jcz push
    uvmnot:
    	nand zero
        nand max
        add call_return
        sav stack_scratch
        nand zero
        nand max
    call_uvmnot_1:
    	jcz uvmnot_1
    uvmnot_1:
    	sav tmp1
        nand tmp1
        sav tmp1
        jcz alu_return

    uvmnand:
    	nand zero
        nand max
        add call_uvmnand_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmnand_1:
    	jcz uvmnand_1
    uvmnand_1:
    	nand stack_tmp1
        sav tmp1
        jcz alu_return

    uvmnor:
    	nand zero
        nand max
        add call_uvmnor_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmnor_1:
    	jcz uvmnor_1
    uvmnor_1:
    	nand tmp1
        sav stack_tmp2
        nand zero
        nand max
        add stack_tmp1
        nand stack_tmp1
        nand stack_tmp2
        sav tmp1
        nand tmp1
        sav tmp1
        jcz alu_return


    uvmor:
    	nand zero
        nand max
        add call_uvmor_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmor_1:
    	jcz uvmor_1
    uvmor_1:
    	nand tmp1
        sav stack_tmp2
        nand zero
        nand max
        add stack_tmp1
        nand stack_tmp1
        nand stack_tmp2
        sav tmp1
        jcz alu_return

    uvmand:
        nand zero
        nand max
        add call_uvmand_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmand_1:
    	jcz uvmand_1
    uvmand_1:
    	nand zero
        nand max
        add stack_tmp1
        nand stack_tmp2
        sav tmp1
        nand tmp1
        sav tmp1
        jcz alu_return


    call_uvmmul_1:
    	jcz uvmmul_1
    uvmmul:
    	nand zero
        nand max
        add call_uvmmul_1
        sav alu_pop_return
        jcz alu_pop
    uvmmul_1:
    	nand zero
        nand max
        add stack_tmp1
        nand neg_one
        sav stack_tmp1
    uvmmul_loop:
    	nand zero
        nand max
        add stack_tmp1
        add one
        jcz uvmmul_cont
        	jcz alu_return ; PUSH tmp1 and return
    uvmmul_cont:
    	sav stack_tmp1
        nand zero
        nand max
        add tmp1
        add stack_tmp2
        sav tmp1
        add zero
        jcz uvmmul_loop

    uvmsub:
    	nand zero
        nand max
        add call_uvmsub_1
        sav alu_pop_return
        jcz alu_pop
    call_uvmsub_1:
    	jcz uvmsub_1
    uvmsub_1:
    	nand zero
        nand max
        add stack_tmp1
        nand stack_tmp1
        add one
        add stack_tmp2
        sav tmp1
        add zero
        jcz alu_return


    call_uvmadd_1:
    	jcz uvmadd_1
    uvmadd:
    	nand zero
        nand max
        add call_uvmadd_1
        sav alu_pop_return
        jcz alu_pop
    uvmadd_1:
    	add stack_tmp1
        sav tmp1
        add zero
        jcz alu_return


    ; end

    ; UVM add
    ; add (sp0 + sp1) => s


    ; call a method
    ; uses rcall to store the return value
    ; which needs to be persisted
    call:
    	add op_jcz
        sav do_call
        nand zero
        nand max
    do_call:
    	jcz zero
    end_call:
    	add zero
    call_return:
    	jcz zero

    call_pop:
    	nand pop
    call_push:
    	nand push
    call_peek:
    	nand peek
    call_dup:
    	nand dup

    skip:
    	nand zero
        nand max
    	add op_add
        add stackp
        add one
        sav dupload
        nand zero
        nand max
        jcz dupload
    dup:
    	nand zero
        nand max
        add op_add
        add stackp
        sav dupload
        nand zero
        nand max
    dupload:
    	add zero
        sav tmp1
        jcz push

    drop:
    	nand zero
        nand max
        add stackp
        add one
        sav stackp
        jcz end_call

    peek:
    	nand zero
        nand max
        add op_add
        add stackp
        sav end_call
        nand zero
        nand max
        jcz end_call
    pop:
    	nand zero
        nand max
    	add op_add
        add stackp
        sav end_call
        nand zero
        nand max
        add stackp
        add one
        sav stackp
    	nand zero
        nand max
        jcz end_call

    push:
    	nand zero
        nand max
        add stackp
        add max
        sav stackp
        add op_sav
        sav end_call
        nand zero
        nand max
        add tmp1
        jcz end_call
        </textarea>

                
        </td>
            <td style="vertical-align: top;">

                <textarea id='terminal' style='resize:none;margin-top:10px;margin-bottom:10px;' readonly cols="80" rows="25" class='small screen'></textarea>
                <div id='file-wrap' class="wrap file">
                    <a class="ultra-btn" id='save-file-btn' href="javascript:saveFile()">Save current</a>
                    <a class="ultra-btn" href="javascript:showRAM()">RAM</a>
                    <a class="ultra-btn" href="javascript:showStack()">Stack</a>
                    <table id="file-table">
                        <thead>
                        <tr>
                            <th>Filename</th><th>Updated</th><th>Action</th>
                        </tr>
                        </thead>
                        <tbody id="file" style="font-size:16px;">

                        </tbody>
                    </table>
                </div>
                <div id='ram-wrap' class="wrap ram" hidden>
                    <a class="ultra-btn" href="javascript:showFiles()">Files</a>
                    <a class="ultra-btn" href="javascript:showStack()">Stack</a>
                    <table id="ram-table">
                        <thead>
                        <tr><th>Address</th><th>Value</th></tr>
                        </thead>
                        <tbody id="ram" style="font-size:16px;max-height:280px;overflow-y: scroll;">

                        </tbody>
                    </table>
                </div>
                <div id='stack-wrap' class="wrap ram" hidden>
                    <a class="ultra-btn" href="javascript:showFiles()">Files</a>
                    <a class="ultra-btn" href="javascript:showRAM()">RAM</a>
                    <table id="stack-table">
                        <thead>
                        <tr><th>Address</th><th>Value</th></tr>
                        </thead>
                        <tbody id="stack" style="font-size:16px;max-height:280px;overflow-y: scroll;">

                        </tbody>
                    </table>
                </div>
            </td>
        
        <!--<th>
            <div class="wrap ram" style="display:none;">

            </div>
        </td>!-->

        </tr>
        </table>
    </body>
</html>